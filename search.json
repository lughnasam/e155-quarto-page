[
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "HMC E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, a DS1722 digital temperature sensor was configured over SPI communications to report temperature when prompted. Simultaneously, an ESP8266 chip was used to host a local server with a website programmed using HTML that was communicated over UART. This website controlled an LED on the demo board, reported temperature and LED status, and allowed changing of LED precision between 8 and 12 bits.\n\n\n\nThe below schematic shows how this circuit was constructed. The DS1722 was connected to a 3V3 power line on three of its pins, the four SPI connections were made with the MCU, and the chip was grounded to the MCU ground.\n Figure 1: Electrical schematic for system\n\n\n\n\n\nAfter initializing, every request from the webpage successfully sent an SPI communication to the DS1722 that updated temperature resolution if necessary, then reported the current temperature of the sensor in Centigrade. This temperature successfully showed changes in precision, showing only an “integer” for 8-bit (no fractional measurement), down to 4 digits of precision for 12-bit (4 bits of fractional measurement). The below digital oscilloscope trace shows a sample SPI transaction, which is reading from register 0x01, the read-only address for the MSBs of the measurement. This was done in 8-bit mode, so showing a data out packet of 0x00 shows that we have an appropriate communication taking place.\n Figure 2: Digital oscilloscope trace\n\n\n\n\nIn this lab, SPI communications were used to interface with a DS1722 temperature sensor and report these temperatures to a webpage on an external chip over UART communications. This lab took me 8 hours overall.\n\n\n\nFollowing the directions for the AI Prototype for lab 6, the following prompt was passed into ChatGPT:\nI’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\nThe AI Model created a website that can be seen below, and it is quite good! It’s even rather aesthetic. Based on prior use I’ve seen for AI, it is very good at JavaScript, TypeScript, HTML, and CSS, so I’m not surprised by its success in this task. It could definitely be tweaked to do exactly what we want in this lab\n Figure 5: Website generated by ChatGPT\nChatGPT was then fed another prompt as stated below:\nWrite me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\nIn response to this prompt, the AI actually wrote code very similar to mine! It instead used an active low chip select, and it also used some of the CMSIS functions and shorthands incorrectly. However, I think the general idea is here and it could be doctored to do what we desire. The SPI code can be seen below.\n Figure 6: Code for SPI initialization from ChatGPT"
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "HMC E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, a DS1722 digital temperature sensor was configured over SPI communications to report temperature when prompted. Simultaneously, an ESP8266 chip was used to host a local server with a website programmed using HTML that was communicated over UART. This website controlled an LED on the demo board, reported temperature and LED status, and allowed changing of LED precision between 8 and 12 bits."
  },
  {
    "objectID": "labs/lab6/lab6.html#schematic",
    "href": "labs/lab6/lab6.html#schematic",
    "title": "HMC E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "The below schematic shows how this circuit was constructed. The DS1722 was connected to a 3V3 power line on three of its pins, the four SPI connections were made with the MCU, and the chip was grounded to the MCU ground.\n Figure 1: Electrical schematic for system"
  },
  {
    "objectID": "labs/lab6/lab6.html#results-and-discussion",
    "href": "labs/lab6/lab6.html#results-and-discussion",
    "title": "HMC E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "After initializing, every request from the webpage successfully sent an SPI communication to the DS1722 that updated temperature resolution if necessary, then reported the current temperature of the sensor in Centigrade. This temperature successfully showed changes in precision, showing only an “integer” for 8-bit (no fractional measurement), down to 4 digits of precision for 12-bit (4 bits of fractional measurement). The below digital oscilloscope trace shows a sample SPI transaction, which is reading from register 0x01, the read-only address for the MSBs of the measurement. This was done in 8-bit mode, so showing a data out packet of 0x00 shows that we have an appropriate communication taking place.\n Figure 2: Digital oscilloscope trace"
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "HMC E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "In this lab, SPI communications were used to interface with a DS1722 temperature sensor and report these temperatures to a webpage on an external chip over UART communications. This lab took me 8 hours overall."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype",
    "href": "labs/lab6/lab6.html#ai-prototype",
    "title": "HMC E155 Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 6, the following prompt was passed into ChatGPT:\nI’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\nThe AI Model created a website that can be seen below, and it is quite good! It’s even rather aesthetic. Based on prior use I’ve seen for AI, it is very good at JavaScript, TypeScript, HTML, and CSS, so I’m not surprised by its success in this task. It could definitely be tweaked to do exactly what we want in this lab\n Figure 5: Website generated by ChatGPT\nChatGPT was then fed another prompt as stated below:\nWrite me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\nIn response to this prompt, the AI actually wrote code very similar to mine! It instead used an active low chip select, and it also used some of the CMSIS functions and shorthands incorrectly. However, I think the general idea is here and it could be doctored to do what we desire. The SPI code can be seen below.\n Figure 6: Code for SPI initialization from ChatGPT"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the timers and a GPIO pin on the STM32L432KC microprocessor was used to control a speaker and play songs using C code. Drivers were created to control both a PWM and a delay counter, and a main function was written to combine the two timers and play audio.\n\n\n\nWhen using the counter in the lab to both control a PWM for the speaker and a timer for note duration, multiple calculations had to be made to ensure calculations were within 1% of specification. Selecting a prescaler value of 16, we need to make sure that we will not overflow our autoreload register with whatever value we must enter. This is determined with the formula \\(ARR = \\frac{f_{sysclk}}{PSC * f_{target}}\\). For 220 Hz, this gives us an \\(ARR\\) value of approx 22,727 and a value of approx 5,000 for 1000 Hz. Plugging these values in to determine the specific frequency we will output, this gives us a value of \\(f_{actual} = 1000\\) when \\(ARR = 5000\\) and a value of \\(f_{actual} = 220.002\\) when \\(ARR = 22,727\\).\nFor the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s.\n\n\n\nThe below schematic shows how this circuit was constructed. Our PWM signal from pin PA6 was fed through a potentiometer and into the LM386 amplifier. This current was run through two capacitors in parallel to create a capacitance of ~250 \\(\\mu F\\) before being fed into the speaker. Decoupling was used as necessary to clean sound.\n Figure 1: Schematic for speaker circuit with amplifier and potentiometer\n\n\n\nUpon running (or resetting) the MCU, the speaker successfully played Fur Elise or played the guitar intro from American Teenager by Ethel Cain. There was no distortion to the sound due to hardware overflows, and the songs played as written (in C arrays).\n\n\n\nIn this lab, I created a set of MCU drivers that appropriately enable system clocks, counters, and a GPIO pin to send a timed-duration PWM signal to a speaker on a breakout board. The system successfully played both Fur Elise by Ludwig van Beethoven and American Teenager by Ethel Cain. Overall, this lab took me 20 hours.\n\n\n\nFollowing the directions for the AI Prototype for lab 4, the following prompt was passed into ChatGPT:\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\nThe model correctly displayed information on the various timers on our STM32L432KC, and then selected TIM2 as the timer we should use. It even wrote code (that seems reasonable at a glance) to generate an A4 on a speaker. This was a useful tool to learn something, but I would definitely want to know neough about it to fact check the AI before I trusted this, and I don’t think people using it would be able to discern the difference.\n Figure 8: Code for the oscillator written by ChatGPT"
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the timers and a GPIO pin on the STM32L432KC microprocessor was used to control a speaker and play songs using C code. Drivers were created to control both a PWM and a delay counter, and a main function was written to combine the two timers and play audio."
  },
  {
    "objectID": "labs/lab4/lab4.html#timer-calculations",
    "href": "labs/lab4/lab4.html#timer-calculations",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "When using the counter in the lab to both control a PWM for the speaker and a timer for note duration, multiple calculations had to be made to ensure calculations were within 1% of specification. Selecting a prescaler value of 16, we need to make sure that we will not overflow our autoreload register with whatever value we must enter. This is determined with the formula \\(ARR = \\frac{f_{sysclk}}{PSC * f_{target}}\\). For 220 Hz, this gives us an \\(ARR\\) value of approx 22,727 and a value of approx 5,000 for 1000 Hz. Plugging these values in to determine the specific frequency we will output, this gives us a value of \\(f_{actual} = 1000\\) when \\(ARR = 5000\\) and a value of \\(f_{actual} = 220.002\\) when \\(ARR = 22,727\\).\nFor the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s."
  },
  {
    "objectID": "labs/lab4/lab4.html#schematic",
    "href": "labs/lab4/lab4.html#schematic",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The below schematic shows how this circuit was constructed. Our PWM signal from pin PA6 was fed through a potentiometer and into the LM386 amplifier. This current was run through two capacitors in parallel to create a capacitance of ~250 \\(\\mu F\\) before being fed into the speaker. Decoupling was used as necessary to clean sound.\n Figure 1: Schematic for speaker circuit with amplifier and potentiometer"
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Upon running (or resetting) the MCU, the speaker successfully played Fur Elise or played the guitar intro from American Teenager by Ethel Cain. There was no distortion to the sound due to hardware overflows, and the songs played as written (in C arrays)."
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I created a set of MCU drivers that appropriately enable system clocks, counters, and a GPIO pin to send a timed-duration PWM signal to a speaker on a breakout board. The system successfully played both Fur Elise by Ludwig van Beethoven and American Teenager by Ethel Cain. Overall, this lab took me 20 hours."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype",
    "href": "labs/lab4/lab4.html#ai-prototype",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 4, the following prompt was passed into ChatGPT:\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\nThe model correctly displayed information on the various timers on our STM32L432KC, and then selected TIM2 as the timer we should use. It even wrote code (that seems reasonable at a glance) to generate an A4 on a speaker. This was a useful tool to learn something, but I would definitely want to know neough about it to fact check the AI before I trusted this, and I don’t think people using it would be able to discern the difference.\n Figure 8: Code for the oscillator written by ChatGPT"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, functional testing was done on a newly constructed E155 development board to confirm that all components placed and soldered onto the board functioned as intended. Following this, a breakout breadboard was constructed to control a 7-segment LED display using switches on the development board. LEDs on the board also implemented combinational logic that was controlled by the same switches, and an oscillating LED was set up using the onboard 48 MHz oscillator native to the iCE40 UltraPlus FPGA.\n\n\n\nThe block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab1_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was written to modulate the clock down to 2.4 Hz on the 31st bit of the counter, allowing it to operate the LED. Two separate decoders were used to determine the values of the 7-segment decoder outputs and the LED outputs based on the 4-input switch and the status of the MSB on the counter.\n Figure 1: Block diagram of hierarchical SystemVerilog\n\n\n\nThe two schematics below show how the LEDs in the given system are powered. The 7-segment display is given a 3.3V input, and pins at the end of them are pulled high to turn off a given segment. The voltage drop across any LED is ~ 2V, and to stay in spec of both the FPGA pin and the operating range of the LED, a 7 mA current was selected. Using this information, the optimal current limiting resistor would have a value of \\(R = \\frac{V}{I} = \\frac{1.3}{.007} = 192 \\Omega\\). Thus, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The switch outputs were also routed through FPGA fabric logic synthesized from SystemVerilog modules with a 1k \\(\\Omega\\) resistor as a current limiting resistor as per board spec.\n Figure 2: Schematic for the onboard LED outputs\n Figure 3: Schematic for the off-board 7-segment LED display\n\n\n\nThe onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The four switches on the development board were used to represent the four binary bits of a hexadecimal number, and these switches also used a SystemVerilog control module to determine when onboard LEDs should be enabled. A control module was written to determine the input hexadecimal number and output the appropriate 7-segment display signals, with the signals themselves being active low. All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\).\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section.\n\n\n\n\n\nAll modules that had custom code written for this lab were verified using automatic Verilog testbenches. These testbenches all confirmed appropriate functionality of the modules, save for the top level, which had issues due to the use of the included HSOSC module on the Radiant software that was not present in QuestaSIM. However, this functionality was confirmed for all lower level modules, and no additional logic exists between the lower level modules and the outputs of the top level modules.\n Figure 4: Testbench results showing no errors when testing the counter\n Figure 5: Testbench results showing no errors when testing the led decoder\n Figure 6: Testbench results showing no errors when testing the 7 segment display decoder\n Figure 7: Testbench waveforms showing the oscillating LED on the top module as well as functioning combinational LED logic\n\n\n\nAll functions of this development board were verified through completion of this lab. Using prewritten test code, the LEDs on the board were verified to work with the SMD 1k \\(\\Omega\\) resistors chosen for the boards. The FPGA was able to control LEDs 5-7, and the MCU was able to control LEDs 1-4. The power LED (0) also worked whenever the board was supplied with an appropriate power feed through USB.\n\n\n\nUpon testing all 16 possible configurations of the switches, appropriate function of the LEDs that functioned based on combinational logic was achieved. Additionally, the 2.4 Hz flashing LED was creating using a counter with a 32 bit register and a P value of 215. Combined with the on-board 48 MHz clock, this achived a frequency of 2.403 Hz on the flashing LED. Appropriate function was also confirmed for the 7-segment LED display, which appropriately displayed values 0-F in hexadecimal.\n\n\n\n\nIn this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 3 LEDs using an oscillator, switches, and combinational logic and controlled a 7-segment LED display using switches and combinational logic. This lab took me 8 hours overall.\n\n\n\nFollowing the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, functional testing was done on a newly constructed E155 development board to confirm that all components placed and soldered onto the board functioned as intended. Following this, a breakout breadboard was constructed to control a 7-segment LED display using switches on the development board. LEDs on the board also implemented combinational logic that was controlled by the same switches, and an oscillating LED was set up using the onboard 48 MHz oscillator native to the iCE40 UltraPlus FPGA."
  },
  {
    "objectID": "labs/lab1/lab1.html#block-diagram",
    "href": "labs/lab1/lab1.html#block-diagram",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab1_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was written to modulate the clock down to 2.4 Hz on the 31st bit of the counter, allowing it to operate the LED. Two separate decoders were used to determine the values of the 7-segment decoder outputs and the LED outputs based on the 4-input switch and the status of the MSB on the counter.\n Figure 1: Block diagram of hierarchical SystemVerilog"
  },
  {
    "objectID": "labs/lab1/lab1.html#schematic",
    "href": "labs/lab1/lab1.html#schematic",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The two schematics below show how the LEDs in the given system are powered. The 7-segment display is given a 3.3V input, and pins at the end of them are pulled high to turn off a given segment. The voltage drop across any LED is ~ 2V, and to stay in spec of both the FPGA pin and the operating range of the LED, a 7 mA current was selected. Using this information, the optimal current limiting resistor would have a value of \\(R = \\frac{V}{I} = \\frac{1.3}{.007} = 192 \\Omega\\). Thus, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The switch outputs were also routed through FPGA fabric logic synthesized from SystemVerilog modules with a 1k \\(\\Omega\\) resistor as a current limiting resistor as per board spec.\n Figure 2: Schematic for the onboard LED outputs\n Figure 3: Schematic for the off-board 7-segment LED display"
  },
  {
    "objectID": "labs/lab1/lab1.html#design-testing-and-methodology",
    "href": "labs/lab1/lab1.html#design-testing-and-methodology",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The four switches on the development board were used to represent the four binary bits of a hexadecimal number, and these switches also used a SystemVerilog control module to determine when onboard LEDs should be enabled. A control module was written to determine the input hexadecimal number and output the appropriate 7-segment display signals, with the signals themselves being active low. All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\).\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "All modules that had custom code written for this lab were verified using automatic Verilog testbenches. These testbenches all confirmed appropriate functionality of the modules, save for the top level, which had issues due to the use of the included HSOSC module on the Radiant software that was not present in QuestaSIM. However, this functionality was confirmed for all lower level modules, and no additional logic exists between the lower level modules and the outputs of the top level modules.\n Figure 4: Testbench results showing no errors when testing the counter\n Figure 5: Testbench results showing no errors when testing the led decoder\n Figure 6: Testbench results showing no errors when testing the 7 segment display decoder\n Figure 7: Testbench waveforms showing the oscillating LED on the top module as well as functioning combinational LED logic\n\n\n\nAll functions of this development board were verified through completion of this lab. Using prewritten test code, the LEDs on the board were verified to work with the SMD 1k \\(\\Omega\\) resistors chosen for the boards. The FPGA was able to control LEDs 5-7, and the MCU was able to control LEDs 1-4. The power LED (0) also worked whenever the board was supplied with an appropriate power feed through USB.\n\n\n\nUpon testing all 16 possible configurations of the switches, appropriate function of the LEDs that functioned based on combinational logic was achieved. Additionally, the 2.4 Hz flashing LED was creating using a counter with a 32 bit register and a P value of 215. Combined with the on-board 48 MHz clock, this achived a frequency of 2.403 Hz on the flashing LED. Appropriate function was also confirmed for the 7-segment LED display, which appropriately displayed values 0-F in hexadecimal."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 3 LEDs using an oscillator, switches, and combinational logic and controlled a 7-segment LED display using switches and combinational logic. This lab took me 8 hours overall."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 23, 2024\n\n\nLughnasa Miller\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Lughnasa Miller is a senior Computer Science major at Harvey Mudd College. She focuses her studies in computer science at the system level, learning about the interaction between low level code and system components and creating embedded systems to solve problems. Outside of the classroom, you can find her playing one of the seven instruments she has learned or organizing queer community through the PRISM club and other engagements."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, a state-based solution was created to independently take the inputs of two 4-segment switches (to represent hex numbers) and display them on a two-diget seven segment display using only one seven segment decoder, necessitating an FSM. A switching frequency was generated, and addtionally, the sum of the two switches at any given time was displayed using a string of LEDs in binary representation.\n\n\n\nThe block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab2_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was reused from lab 1 to modulate the clock down to ~90 Hz on the 17st bit of the counter, allowing it to oscillate the power between our two sides of the seven segment display, also representing our two states. A single decoder determined the multiplexed selection between the two switch outputs, and a full adder determined the LED binary output.\n Figure 1: Block diagram of hierarchical SystemVerilog\n\n\n\nThe two schematics below show how the LEDs in the given system are powered. The 7-segment display common power pins are given a ~3.3V input through a PNP transistor with 1 \\(\\mu A\\) at the base (necessitating an ~330 \\(\\Omega\\) resistor), and pins at the end of them are pulled high to turn off a given segment. Only one set of pins was powered and pulled appropriately at any given time, and the 90 Hz oscillating frequency ensured stable powering without blending of the two signals. As per the last lab, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The pins connected to the breakout switch were connected to ground with pullup resistors set on the FPGA pins.\n Figure 2: Schematic for the breakout board\n\n\n\nThe onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The switch banks on the development board and breakout board were used to represent the four binary bits of two hexadecimal numbers, and these switches fed into a full adder to determine when onboard LEDs should be enabled. A state machine toggled between the two switch inputs into the decoder, powering the relevant side of the seven segment display in the process All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\). A 330 \\(\\Omega\\) resistor was used from the enable pins to power into the base of a PNP transistor with a target current of 1 \\(\\mu A\\). This then fed into the seven segment display from a 3V3 feed on the collector, and the transistors with oscillating base inputs swapped power at about 90 Hz.\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section.\n\n\n\n\n\nNewly written modules (enabled FF and top level) were tested using automated verilog testbenches to ensure that all sums were correct in the outputs, that the power pins swapped at the correct frequency, and that the enabled FF worked as intended. See all testbench results below.\n Figure 3: Testbench waveforms showing the oscillating power states on the top module as well as functioning combinational LED logic\n Figure 4: Testbench results showing no errors when testing the counter\n\n\n\nTesting verification was done to confirm that the seven segment and LEDs displayed appropriate outputs based on switched inputs. All segments were equally bright, and there was no blending between the two displays due to coupling between the two inputs.\n\n\n\n\nIn this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 5 LEDs using a full adder, and used an oscillating FSM to control two separate seven segment LED displays using one decoder. Overall, I spent 5 hours on this lab.\n\n\n\nFollowing the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, a state-based solution was created to independently take the inputs of two 4-segment switches (to represent hex numbers) and display them on a two-diget seven segment display using only one seven segment decoder, necessitating an FSM. A switching frequency was generated, and addtionally, the sum of the two switches at any given time was displayed using a string of LEDs in binary representation."
  },
  {
    "objectID": "labs/lab2/lab2.html#block-diagram",
    "href": "labs/lab2/lab2.html#block-diagram",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab2_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was reused from lab 1 to modulate the clock down to ~90 Hz on the 17st bit of the counter, allowing it to oscillate the power between our two sides of the seven segment display, also representing our two states. A single decoder determined the multiplexed selection between the two switch outputs, and a full adder determined the LED binary output.\n Figure 1: Block diagram of hierarchical SystemVerilog"
  },
  {
    "objectID": "labs/lab2/lab2.html#schematic",
    "href": "labs/lab2/lab2.html#schematic",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The two schematics below show how the LEDs in the given system are powered. The 7-segment display common power pins are given a ~3.3V input through a PNP transistor with 1 \\(\\mu A\\) at the base (necessitating an ~330 \\(\\Omega\\) resistor), and pins at the end of them are pulled high to turn off a given segment. Only one set of pins was powered and pulled appropriately at any given time, and the 90 Hz oscillating frequency ensured stable powering without blending of the two signals. As per the last lab, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The pins connected to the breakout switch were connected to ground with pullup resistors set on the FPGA pins.\n Figure 2: Schematic for the breakout board"
  },
  {
    "objectID": "labs/lab2/lab2.html#design-testing-and-methodology",
    "href": "labs/lab2/lab2.html#design-testing-and-methodology",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The switch banks on the development board and breakout board were used to represent the four binary bits of two hexadecimal numbers, and these switches fed into a full adder to determine when onboard LEDs should be enabled. A state machine toggled between the two switch inputs into the decoder, powering the relevant side of the seven segment display in the process All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\). A 330 \\(\\Omega\\) resistor was used from the enable pins to power into the base of a PNP transistor with a target current of 1 \\(\\mu A\\). This then fed into the seven segment display from a 3V3 feed on the collector, and the transistors with oscillating base inputs swapped power at about 90 Hz.\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Newly written modules (enabled FF and top level) were tested using automated verilog testbenches to ensure that all sums were correct in the outputs, that the power pins swapped at the correct frequency, and that the enabled FF worked as intended. See all testbench results below.\n Figure 3: Testbench waveforms showing the oscillating power states on the top module as well as functioning combinational LED logic\n Figure 4: Testbench results showing no errors when testing the counter\n\n\n\nTesting verification was done to confirm that the seven segment and LEDs displayed appropriate outputs based on switched inputs. All segments were equally bright, and there was no blending between the two displays due to coupling between the two inputs."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 5 LEDs using a full adder, and used an oscillating FSM to control two separate seven segment LED displays using one decoder. Overall, I spent 5 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, interrupts and GPIO pins were configured with a counter on the STM32L432KC to read a quadrature encoder on a TS-25GA370H-34 motor. This quadrature encoder reading was used to determine angular velocity of the motor.\n\n\n\nFor the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s. This enabled us to create a simple 1 Hz telemetry loop that reports velocity and direction of rotation for this lab.\n\n\n\nThe below schematic shows how this circuit was constructed. An external 20V variable power supply was connected to the power and ground pins for our motor we used for testing our system. The 5V, GND, quadrature A, and quadrature B pins were connected to their corresponding MCU pins directly. All pins were enabled with pull-up resistors.\n Figure 1: Electrical schematic for system\n\n\n\nThe below diagram shows the control loop present in this system. A main loop ran a 1 Hz cycle that printed velocity and reset counter values before repeating, giving us a telemetry status. The two interrupts both incremented a counter that tracked the number of quadrature encoder edges seen in the past second, and they also tracked which interrupt was last checked. If the same interrupt triggered 2x in a row, it meant that the motor had changed direction, which we could track globally.\n Figure 2: Interrupt diagram for system\n\n\n\n\n\nWhen initializing the program, the code appropriately output a 0 for velocity. Upon activating, it correctly determined our control velocity for the motor (2.4 rev/sec at 10 V), and was also able to detect changes in direction when reversing the current path through the motor.\n\n\n\nWe were able to test the speed of entering an interrupt v.s. reading a toggled pin with polling by writing code to simulate both situations. First set the start of our interrupt function to toggle a pin on, then read the time between an interrupt being raised and the pin being toggled. As seen below, the time from the onset of an interrupt signal to the first line of the function that toggled the pin took 26.4 \\(\\mu s\\). By comparison, having a polling loop that toggled a pin then read an input took 63.6 \\(\\mu s\\). This indicates that interrupts will be more efficient when polling at the rate that we will be at.\nWe know that the onset and offset time will be equal to enter these “interrupts” and increment our counter, and they are significantly longer than the code they surround. Thus, we can calculate maximum rpm using the equation \\(\\frac{(t_{onset} * 2)^{-1}}{4*PPR} = \\omega_{max}\\). For polling, this is found to be 4.81 rpm, and for interrupts it is found to be 11.61 rpm.\n Figure 3: Oscilloscope trace showing interrupt response time\n Figure 4: Oscilloscope trace showing polling response time\n\n\n\n\nIn this lab, I created an interrupt based velocity measurement system using the quadrature encoders present on a 25GA-370 motor. The motor correctly determined direction changes and velocity magnitude. Overall, this lab took me 9 hours.\n\n\n\nFollowing the directions for the AI Prototype for lab 5, the following prompt was passed into ChatGPT:\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\nThe AI model did not do very well on this task. The first thing it did was enable interrupts for every edge of the program. However, it missed setting some of the signal select muxes that tell the interrupt handlers where to look for interrupt signals. As a result, this code did not successfully run because it couldn’t recognize interrupts. See the below code from GPT.\n Figure 5: Code for the interrupt enables written by ChatGPT, which is missing key register writes\nThe interrupt handler itself also has a critical bug, which will incorrectly decrement the counter when \\(A == B\\). As a result, I do not believe this code would have correctly incremented and tracked speed, outputting something very close to 0 every telemetry frame.\n Figure 6: Code for interrupt handlers written by ChatGPT, which does not correctly increment counter"
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, interrupts and GPIO pins were configured with a counter on the STM32L432KC to read a quadrature encoder on a TS-25GA370H-34 motor. This quadrature encoder reading was used to determine angular velocity of the motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#timer-calculations",
    "href": "labs/lab5/lab5.html#timer-calculations",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "For the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s. This enabled us to create a simple 1 Hz telemetry loop that reports velocity and direction of rotation for this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#schematic",
    "href": "labs/lab5/lab5.html#schematic",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "The below schematic shows how this circuit was constructed. An external 20V variable power supply was connected to the power and ground pins for our motor we used for testing our system. The 5V, GND, quadrature A, and quadrature B pins were connected to their corresponding MCU pins directly. All pins were enabled with pull-up resistors.\n Figure 1: Electrical schematic for system"
  },
  {
    "objectID": "labs/lab5/lab5.html#interrupt-diagram",
    "href": "labs/lab5/lab5.html#interrupt-diagram",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "The below diagram shows the control loop present in this system. A main loop ran a 1 Hz cycle that printed velocity and reset counter values before repeating, giving us a telemetry status. The two interrupts both incremented a counter that tracked the number of quadrature encoder edges seen in the past second, and they also tracked which interrupt was last checked. If the same interrupt triggered 2x in a row, it meant that the motor had changed direction, which we could track globally.\n Figure 2: Interrupt diagram for system"
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "When initializing the program, the code appropriately output a 0 for velocity. Upon activating, it correctly determined our control velocity for the motor (2.4 rev/sec at 10 V), and was also able to detect changes in direction when reversing the current path through the motor.\n\n\n\nWe were able to test the speed of entering an interrupt v.s. reading a toggled pin with polling by writing code to simulate both situations. First set the start of our interrupt function to toggle a pin on, then read the time between an interrupt being raised and the pin being toggled. As seen below, the time from the onset of an interrupt signal to the first line of the function that toggled the pin took 26.4 \\(\\mu s\\). By comparison, having a polling loop that toggled a pin then read an input took 63.6 \\(\\mu s\\). This indicates that interrupts will be more efficient when polling at the rate that we will be at.\nWe know that the onset and offset time will be equal to enter these “interrupts” and increment our counter, and they are significantly longer than the code they surround. Thus, we can calculate maximum rpm using the equation \\(\\frac{(t_{onset} * 2)^{-1}}{4*PPR} = \\omega_{max}\\). For polling, this is found to be 4.81 rpm, and for interrupts it is found to be 11.61 rpm.\n Figure 3: Oscilloscope trace showing interrupt response time\n Figure 4: Oscilloscope trace showing polling response time"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "In this lab, I created an interrupt based velocity measurement system using the quadrature encoders present on a 25GA-370 motor. The motor correctly determined direction changes and velocity magnitude. Overall, this lab took me 9 hours."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype",
    "href": "labs/lab5/lab5.html#ai-prototype",
    "title": "HMC E155 Lab 5: Interrupts",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 5, the following prompt was passed into ChatGPT:\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\nThe AI model did not do very well on this task. The first thing it did was enable interrupts for every edge of the program. However, it missed setting some of the signal select muxes that tell the interrupt handlers where to look for interrupt signals. As a result, this code did not successfully run because it couldn’t recognize interrupts. See the below code from GPT.\n Figure 5: Code for the interrupt enables written by ChatGPT, which is missing key register writes\nThe interrupt handler itself also has a critical bug, which will incorrectly decrement the counter when \\(A == B\\). As a result, I do not believe this code would have correctly incremented and tracked speed, outputting something very close to 0 every telemetry frame.\n Figure 6: Code for interrupt handlers written by ChatGPT, which does not correctly increment counter"
  },
  {
    "objectID": "labs/project_overview/project_overview.html",
    "href": "labs/project_overview/project_overview.html",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our final project will be to design and build a digital guitar amplifier capable of producing 4 audio effects: distortion, reverb, vibrato, and chorus. Using an iCE 40UP5K FPGA and an ADC, we will sample our guitar output and perform all effects related to time-delay. An STM32L432KC microcontroller will perform all modifications that change the amplitude of our signal in a non-linear way as well as converting our digital signal back to an analog one before recentering and playing our signal.\n\n\n\nOur system will meet the following specifications upon completion:\n\nPlay the processed audio output from a guitar on a speaker.\nImplement real-time digital effects processing on an STM32L432KC microcontroller.\nInterface a UPduino FPGA for control logic and foot pedal input handling.\nPass a clear audio sample through the FPGA memory architecture.\nDesign and integrate an audio amplifier output stage capable of directly driving a small guitar speaker or external cabinet.\nDevelop a low-noise analog front-end for clean audio acquisition and output.\nCreate a user-friendly interface using foot pedals for live control and effect toggling.\n\n\n\n\nThe system consists of the following components:\nThe amplifier system consists of the following main components:\n\nSTM32L432KC MCU:\n\nTakes sampled input data from the FPGA and applies some audio distortion effects. Drives the speaker through an audio amplifier by outputting a wave signal through a DAC channel\n\nUPduino (Lattice iCE40 FPGA):\n\nTakes input from ADC, samples the input frequency and subsequently does some of the delay based audio effects. Outputs the sampled signal or the modified signal to the MCU through SPI communication. Handles the input controls from some of the toggle switches.\n\nAnalog Front-End:\n\nIncludes preamplification, signal conditioning, and level shifting circuits to ensure proper ADC input voltage levels and low-noise operation. The output stage reconditions the signal for amplifier or headphone output.\n\nFoot Pedal Controls:\n\nUp to four pedals are used to toggle each effect (reverb, delay, chorus, distortion) on or off, as well as adjust intensity parameters such as delay time, chorus depth, or reverb level.\n\nAmplifier Output:\n\nPerforms amplification of signal from the MCU which is passed through an audio amplifier chip that drives into a guitar amp.\n\n\n\n\n\nThe FPGA will communicate with an ADC over a serial communication protocol, enabling it to read in 12-bit analog signal. This information will be stored in the FPGA memory before being read out at various times to implement delay based effects in our sound.\n\n\n\nIn this project, the MCU will take data over SPI communications from the FPGA. After this, the MCU will determine whether a distortion and/or vibrato effect should be applied to the signal. It will apply the relevant transformations, and then it will use the onboard DAC to convert back to an analog signal before outputting through the second stage amplifier.\n\n\n\nOur design has two main points that will be high-risk areas for our design: the FPGA design with an unfamiliar component (SRAM) and the analog preamplifier to bring the guitar’s output signal into range for the ADC (0-3.3 V). This design was talked about in class, and we should be able to use the information from lecture to create a preamplifier and appropriately generate our offset. Additionally, when using the SRAM on the FPGA, we should be extra careful to understand the datasheet fully in order to correctly implement the memory-based delay effects.\n\n\n\nTwo major points of our circuit will need to be calculated to find optimal operating conditions; these are the input and output points as well as the internal DSP relevant to making all desired effects.\nOn the analog side, input signal ranges from 0.1 to 1.0 Vpp centered around 0 V, with a frequency between 80 and 5000 Hz. We need to be able to shift the signal and amplify to fit the FPGA input specs of 0 to 3.3 V. this means, for an op-amp:\n\nSlew rate\n\n\\(SR \\geq 2 \\pi f_{max} V_{pk}\\)\n\\(SR \\geq 5 \\frac{V}{\\mu s}\\)\n\nGBW Product\n\nIf max closed loop gain is 10, and we desire a flat response to 100 KHz, choose \\(GBW \\geq 10 * 100 kHz = 1 MHz\\)\n\n\nFor the digital domain, we are mostly worried about the effects of aliasing on our sampled data. Because distortion works by clipping the extreme ranges of our signal, and chorus and reverb work by slightly delaying the phase of our signal before recombining it in some ratio, sampling at a much larger rate than our output frequency (44100 KHz) will enable an appropriately high fidelity output.\n\n\n\nThe following block diagram shows how signals will flow through the system.\n Figure 1: Block diagram of system design\nThe guitar signal will be sent through a pre-processing amplifier that will limit noise as well as increasing the voltage of the guitar’s signal to a readable level. The FPGA will read the signal and convert it to digital, as well as applying the reverb and chorus effects if those pedals are active. The signal is then passed over SPI communication to the MCU, where the distortion and vibrato effects can be applied. Finally, the MCU will use its onboard DAC to convert the signal back to analog, where it will encounter a post-processing amplifier before going into a guitar amplifier.\n\n\n\nThe following GANTT chart shows how work will be broken down over the 5 weeks given for the project.\n Figure 2: GANTT chart showing schedule for project over 5 weeks\n\n\n\nBelow is the bill of materials we have planned for this project:\n Figure 3: BoM for project"
  },
  {
    "objectID": "labs/project_overview/project_overview.html#description",
    "href": "labs/project_overview/project_overview.html#description",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our final project will be to design and build a digital guitar amplifier capable of producing 4 audio effects: distortion, reverb, vibrato, and chorus. Using an iCE 40UP5K FPGA and an ADC, we will sample our guitar output and perform all effects related to time-delay. An STM32L432KC microcontroller will perform all modifications that change the amplitude of our signal in a non-linear way as well as converting our digital signal back to an analog one before recentering and playing our signal."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#system-specifications",
    "href": "labs/project_overview/project_overview.html#system-specifications",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our system will meet the following specifications upon completion:\n\nPlay the processed audio output from a guitar on a speaker.\nImplement real-time digital effects processing on an STM32L432KC microcontroller.\nInterface a UPduino FPGA for control logic and foot pedal input handling.\nPass a clear audio sample through the FPGA memory architecture.\nDesign and integrate an audio amplifier output stage capable of directly driving a small guitar speaker or external cabinet.\nDevelop a low-noise analog front-end for clean audio acquisition and output.\nCreate a user-friendly interface using foot pedals for live control and effect toggling."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#system-overview",
    "href": "labs/project_overview/project_overview.html#system-overview",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The system consists of the following components:\nThe amplifier system consists of the following main components:\n\nSTM32L432KC MCU:\n\nTakes sampled input data from the FPGA and applies some audio distortion effects. Drives the speaker through an audio amplifier by outputting a wave signal through a DAC channel\n\nUPduino (Lattice iCE40 FPGA):\n\nTakes input from ADC, samples the input frequency and subsequently does some of the delay based audio effects. Outputs the sampled signal or the modified signal to the MCU through SPI communication. Handles the input controls from some of the toggle switches.\n\nAnalog Front-End:\n\nIncludes preamplification, signal conditioning, and level shifting circuits to ensure proper ADC input voltage levels and low-noise operation. The output stage reconditions the signal for amplifier or headphone output.\n\nFoot Pedal Controls:\n\nUp to four pedals are used to toggle each effect (reverb, delay, chorus, distortion) on or off, as well as adjust intensity parameters such as delay time, chorus depth, or reverb level.\n\nAmplifier Output:\n\nPerforms amplification of signal from the MCU which is passed through an audio amplifier chip that drives into a guitar amp."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#fpga-design-details",
    "href": "labs/project_overview/project_overview.html#fpga-design-details",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The FPGA will communicate with an ADC over a serial communication protocol, enabling it to read in 12-bit analog signal. This information will be stored in the FPGA memory before being read out at various times to implement delay based effects in our sound."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#mcu-design-details",
    "href": "labs/project_overview/project_overview.html#mcu-design-details",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "In this project, the MCU will take data over SPI communications from the FPGA. After this, the MCU will determine whether a distortion and/or vibrato effect should be applied to the signal. It will apply the relevant transformations, and then it will use the onboard DAC to convert back to an analog signal before outputting through the second stage amplifier."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#riskiest-elements",
    "href": "labs/project_overview/project_overview.html#riskiest-elements",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Our design has two main points that will be high-risk areas for our design: the FPGA design with an unfamiliar component (SRAM) and the analog preamplifier to bring the guitar’s output signal into range for the ADC (0-3.3 V). This design was talked about in class, and we should be able to use the information from lecture to create a preamplifier and appropriately generate our offset. Additionally, when using the SRAM on the FPGA, we should be extra careful to understand the datasheet fully in order to correctly implement the memory-based delay effects."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#calculations",
    "href": "labs/project_overview/project_overview.html#calculations",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Two major points of our circuit will need to be calculated to find optimal operating conditions; these are the input and output points as well as the internal DSP relevant to making all desired effects.\nOn the analog side, input signal ranges from 0.1 to 1.0 Vpp centered around 0 V, with a frequency between 80 and 5000 Hz. We need to be able to shift the signal and amplify to fit the FPGA input specs of 0 to 3.3 V. this means, for an op-amp:\n\nSlew rate\n\n\\(SR \\geq 2 \\pi f_{max} V_{pk}\\)\n\\(SR \\geq 5 \\frac{V}{\\mu s}\\)\n\nGBW Product\n\nIf max closed loop gain is 10, and we desire a flat response to 100 KHz, choose \\(GBW \\geq 10 * 100 kHz = 1 MHz\\)\n\n\nFor the digital domain, we are mostly worried about the effects of aliasing on our sampled data. Because distortion works by clipping the extreme ranges of our signal, and chorus and reverb work by slightly delaying the phase of our signal before recombining it in some ratio, sampling at a much larger rate than our output frequency (44100 KHz) will enable an appropriately high fidelity output."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#block-diagram",
    "href": "labs/project_overview/project_overview.html#block-diagram",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The following block diagram shows how signals will flow through the system.\n Figure 1: Block diagram of system design\nThe guitar signal will be sent through a pre-processing amplifier that will limit noise as well as increasing the voltage of the guitar’s signal to a readable level. The FPGA will read the signal and convert it to digital, as well as applying the reverb and chorus effects if those pedals are active. The signal is then passed over SPI communication to the MCU, where the distortion and vibrato effects can be applied. Finally, the MCU will use its onboard DAC to convert the signal back to analog, where it will encounter a post-processing amplifier before going into a guitar amplifier."
  },
  {
    "objectID": "labs/project_overview/project_overview.html#schedule-and-work-breakdown",
    "href": "labs/project_overview/project_overview.html#schedule-and-work-breakdown",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "The following GANTT chart shows how work will be broken down over the 5 weeks given for the project.\n Figure 2: GANTT chart showing schedule for project over 5 weeks"
  },
  {
    "objectID": "labs/project_overview/project_overview.html#bill-of-materialsbudget",
    "href": "labs/project_overview/project_overview.html#bill-of-materialsbudget",
    "title": "E155 Final Project: Multi-Effect Guitar Pedal",
    "section": "",
    "text": "Below is the bill of materials we have planned for this project:\n Figure 3: BoM for project"
  }
]