[
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the timers and a GPIO pin on the STM32L432KC microprocessor was used to control a speaker and play songs using C code. Drivers were created to control both a PWM and a delay counter, and a main function was written to combine the two functions.\n\n\n\nWhen using the counter in the lab to both control a PWM for the speaker and a timer for note duration, multiple calculations had to be made to ensure calculations were within 1% of specification. Selecting a prescaler value of 16, we need to make sure that we will not overflow our autoreload register with whatever value we must enter. This is determined with the formula $ARR = . For 220 Hz, this gives us an \\(ARR\\) value of approx 22,727 and a value of approx 5,000 for 1000 Hz. Plugging these values in to determine the specific frequency we will output, this gives us a value of \\(f_{target} = 1000\\) when \\(ARR = 5000\\) and a value of \\(f_{target} = 220.002\\) when \\(ARR = 22,727\\).\nFor the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s.\n\n\n\nThe below schematic shows how this circuit was constructed. Our PWM signal from pin __ was fed through a potentiometer and into the LM386 amplifier. This current was run through two capacitors in parallel to create a capacitance of 250 \\(\\mu F\\) before being fed into the speaker. Decoupling was used as necessary.\n UPDATE F\n\n\n\n\n\nUpon running (or resetting) the MCU, the speaker successfully played Fur Elise, paused, and then played the guitar riff from American Teenager by Ethel Cain. There was no distortion to the sound due to hardware overflows, and the songs played as written (in C arrays).\n\n\n\n\nIn this lab, I created a set of MCU drivers that appropriately enable system clocks, counters, and a GPIO pin to send a timed-duration PWM signal to a speaker on a breakout board. The system successfully played both Fur Elise by Beethoven and American Teenager by Ethel Cain. Overall, this lab took me 12 hours.\n\n\n\nFollowing the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, the timers and a GPIO pin on the STM32L432KC microprocessor was used to control a speaker and play songs using C code. Drivers were created to control both a PWM and a delay counter, and a main function was written to combine the two functions."
  },
  {
    "objectID": "labs/lab4/lab4.html#timer-calculations",
    "href": "labs/lab4/lab4.html#timer-calculations",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "When using the counter in the lab to both control a PWM for the speaker and a timer for note duration, multiple calculations had to be made to ensure calculations were within 1% of specification. Selecting a prescaler value of 16, we need to make sure that we will not overflow our autoreload register with whatever value we must enter. This is determined with the formula $ARR = . For 220 Hz, this gives us an \\(ARR\\) value of approx 22,727 and a value of approx 5,000 for 1000 Hz. Plugging these values in to determine the specific frequency we will output, this gives us a value of \\(f_{target} = 1000\\) when \\(ARR = 5000\\) and a value of \\(f_{target} = 220.002\\) when \\(ARR = 22,727\\).\nFor the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s."
  },
  {
    "objectID": "labs/lab4/lab4.html#schematic",
    "href": "labs/lab4/lab4.html#schematic",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The below schematic shows how this circuit was constructed. Our PWM signal from pin __ was fed through a potentiometer and into the LM386 amplifier. This current was run through two capacitors in parallel to create a capacitance of 250 \\(\\mu F\\) before being fed into the speaker. Decoupling was used as necessary.\n UPDATE F"
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Upon running (or resetting) the MCU, the speaker successfully played Fur Elise, paused, and then played the guitar riff from American Teenager by Ethel Cain. There was no distortion to the sound due to hardware overflows, and the songs played as written (in C arrays)."
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I created a set of MCU drivers that appropriately enable system clocks, counters, and a GPIO pin to send a timed-duration PWM signal to a speaker on a breakout board. The system successfully played both Fur Elise by Beethoven and American Teenager by Ethel Cain. Overall, this lab took me 12 hours."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype",
    "href": "labs/lab4/lab4.html#ai-prototype",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, functional testing was done on a newly constructed E155 development board to confirm that all components placed and soldered onto the board functioned as intended. Following this, a breakout breadboard was constructed to control a 7-segment LED display using switches on the development board. LEDs on the board also implemented combinational logic that was controlled by the same switches, and an oscillating LED was set up using the onboard 48 MHz oscillator native to the iCE40 UltraPlus FPGA.\n\n\n\nThe block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab1_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was written to modulate the clock down to 2.4 Hz on the 31st bit of the counter, allowing it to operate the LED. Two separate decoders were used to determine the values of the 7-segment decoder outputs and the LED outputs based on the 4-input switch and the status of the MSB on the counter.\n Figure 1: Block diagram of hierarchical SystemVerilog\n\n\n\nThe two schematics below show how the LEDs in the given system are powered. The 7-segment display is given a 3.3V input, and pins at the end of them are pulled high to turn off a given segment. The voltage drop across any LED is ~ 2V, and to stay in spec of both the FPGA pin and the operating range of the LED, a 7 mA current was selected. Using this information, the optimal current limiting resistor would have a value of \\(R = \\frac{V}{I} = \\frac{1.3}{.007} = 192 \\Omega\\). Thus, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The switch outputs were also routed through FPGA fabric logic synthesized from SystemVerilog modules with a 1k \\(\\Omega\\) resistor as a current limiting resistor as per board spec.\n Figure 2: Schematic for the onboard LED outputs\n Figure 3: Schematic for the off-board 7-segment LED display\n\n\n\nThe onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The four switches on the development board were used to represent the four binary bits of a hexadecimal number, and these switches also used a SystemVerilog control module to determine when onboard LEDs should be enabled. A control module was written to determine the input hexadecimal number and output the appropriate 7-segment display signals, with the signals themselves being active low. All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\).\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section.\n\n\n\n\n\nAll modules that had custom code written for this lab were verified using automatic Verilog testbenches. These testbenches all confirmed appropriate functionality of the modules, save for the top level, which had issues due to the use of the included HSOSC module on the Radiant software that was not present in QuestaSIM. However, this functionality was confirmed for all lower level modules, and no additional logic exists between the lower level modules and the outputs of the top level modules.\n Figure 4: Testbench results showing no errors when testing the counter\n Figure 5: Testbench results showing no errors when testing the led decoder\n Figure 6: Testbench results showing no errors when testing the 7 segment display decoder\n Figure 7: Testbench waveforms showing the oscillating LED on the top module as well as functioning combinational LED logic\n\n\n\nAll functions of this development board were verified through completion of this lab. Using prewritten test code, the LEDs on the board were verified to work with the SMD 1k \\(\\Omega\\) resistors chosen for the boards. The FPGA was able to control LEDs 5-7, and the MCU was able to control LEDs 1-4. The power LED (0) also worked whenever the board was supplied with an appropriate power feed through USB.\n\n\n\nUpon testing all 16 possible configurations of the switches, appropriate function of the LEDs that functioned based on combinational logic was achieved. Additionally, the 2.4 Hz flashing LED was creating using a counter with a 32 bit register and a P value of 215. Combined with the on-board 48 MHz clock, this achived a frequency of 2.403 Hz on the flashing LED. Appropriate function was also confirmed for the 7-segment LED display, which appropriately displayed values 0-F in hexadecimal.\n\n\n\n\nIn this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 3 LEDs using an oscillator, switches, and combinational logic and controlled a 7-segment LED display using switches and combinational logic. This lab took me 8 hours overall.\n\n\n\nFollowing the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, functional testing was done on a newly constructed E155 development board to confirm that all components placed and soldered onto the board functioned as intended. Following this, a breakout breadboard was constructed to control a 7-segment LED display using switches on the development board. LEDs on the board also implemented combinational logic that was controlled by the same switches, and an oscillating LED was set up using the onboard 48 MHz oscillator native to the iCE40 UltraPlus FPGA."
  },
  {
    "objectID": "labs/lab1/lab1.html#block-diagram",
    "href": "labs/lab1/lab1.html#block-diagram",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab1_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was written to modulate the clock down to 2.4 Hz on the 31st bit of the counter, allowing it to operate the LED. Two separate decoders were used to determine the values of the 7-segment decoder outputs and the LED outputs based on the 4-input switch and the status of the MSB on the counter.\n Figure 1: Block diagram of hierarchical SystemVerilog"
  },
  {
    "objectID": "labs/lab1/lab1.html#schematic",
    "href": "labs/lab1/lab1.html#schematic",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The two schematics below show how the LEDs in the given system are powered. The 7-segment display is given a 3.3V input, and pins at the end of them are pulled high to turn off a given segment. The voltage drop across any LED is ~ 2V, and to stay in spec of both the FPGA pin and the operating range of the LED, a 7 mA current was selected. Using this information, the optimal current limiting resistor would have a value of \\(R = \\frac{V}{I} = \\frac{1.3}{.007} = 192 \\Omega\\). Thus, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The switch outputs were also routed through FPGA fabric logic synthesized from SystemVerilog modules with a 1k \\(\\Omega\\) resistor as a current limiting resistor as per board spec.\n Figure 2: Schematic for the onboard LED outputs\n Figure 3: Schematic for the off-board 7-segment LED display"
  },
  {
    "objectID": "labs/lab1/lab1.html#design-testing-and-methodology",
    "href": "labs/lab1/lab1.html#design-testing-and-methodology",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The four switches on the development board were used to represent the four binary bits of a hexadecimal number, and these switches also used a SystemVerilog control module to determine when onboard LEDs should be enabled. A control module was written to determine the input hexadecimal number and output the appropriate 7-segment display signals, with the signals themselves being active low. All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\).\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "All modules that had custom code written for this lab were verified using automatic Verilog testbenches. These testbenches all confirmed appropriate functionality of the modules, save for the top level, which had issues due to the use of the included HSOSC module on the Radiant software that was not present in QuestaSIM. However, this functionality was confirmed for all lower level modules, and no additional logic exists between the lower level modules and the outputs of the top level modules.\n Figure 4: Testbench results showing no errors when testing the counter\n Figure 5: Testbench results showing no errors when testing the led decoder\n Figure 6: Testbench results showing no errors when testing the 7 segment display decoder\n Figure 7: Testbench waveforms showing the oscillating LED on the top module as well as functioning combinational LED logic\n\n\n\nAll functions of this development board were verified through completion of this lab. Using prewritten test code, the LEDs on the board were verified to work with the SMD 1k \\(\\Omega\\) resistors chosen for the boards. The FPGA was able to control LEDs 5-7, and the MCU was able to control LEDs 1-4. The power LED (0) also worked whenever the board was supplied with an appropriate power feed through USB.\n\n\n\nUpon testing all 16 possible configurations of the switches, appropriate function of the LEDs that functioned based on combinational logic was achieved. Additionally, the 2.4 Hz flashing LED was creating using a counter with a 32 bit register and a P value of 215. Combined with the on-board 48 MHz clock, this achived a frequency of 2.403 Hz on the flashing LED. Appropriate function was also confirmed for the 7-segment LED display, which appropriately displayed values 0-F in hexadecimal."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 3 LEDs using an oscillator, switches, and combinational logic and controlled a 7-segment LED display using switches and combinational logic. This lab took me 8 hours overall."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype",
    "href": "labs/lab1/lab1.html#ai-prototype",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Hello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 23, 2024\n\n\nLughnasa Miller\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Lughnasa Miller is a senior Computer Science major at Harvey Mudd College. She focuses her studies in computer science at the system level, learning about the interaction between low level code and system components and creating embedded systems to solve problems. Outside of the classroom, you can find her playing one of the seven instruments she has learned or organizing queer community through the PRISM club and other engagements."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, a state-based solution was created to independently take the inputs of two 4-segment switches (to represent hex numbers) and display them on a two-diget seven segment display using only one seven segment decoder, necessitating an FSM. A switching frequency was generated, and addtionally, the sum of the two switches at any given time was displayed using a string of LEDs in binary representation.\n\n\n\nThe block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab2_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was reused from lab 1 to modulate the clock down to ~90 Hz on the 17st bit of the counter, allowing it to oscillate the power between our two sides of the seven segment display, also representing our two states. A single decoder determined the multiplexed selection between the two switch outputs, and a full adder determined the LED binary output.\n Figure 1: Block diagram of hierarchical SystemVerilog\n\n\n\nThe two schematics below show how the LEDs in the given system are powered. The 7-segment display common power pins are given a ~3.3V input through a PNP transistor with 1 \\(\\mu A\\) at the base (necessitating an ~330 \\(\\Omega\\) resistor), and pins at the end of them are pulled high to turn off a given segment. Only one set of pins was powered and pulled appropriately at any given time, and the 90 Hz oscillating frequency ensured stable powering without blending of the two signals. As per the last lab, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The pins connected to the breakout switch were connected to ground with pullup resistors set on the FPGA pins.\n Figure 2: Schematic for the breakout board\n\n\n\nThe onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The switch banks on the development board and breakout board were used to represent the four binary bits of two hexadecimal numbers, and these switches fed into a full adder to determine when onboard LEDs should be enabled. A state machine toggled between the two switch inputs into the decoder, powering the relevant side of the seven segment display in the process All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\). A 330 \\(\\Omega\\) resistor was used from the enable pins to power into the base of a PNP transistor with a target current of 1 \\(\\mu A\\). This then fed into the seven segment display from a 3V3 feed on the collector, and the transistors with oscillating base inputs swapped power at about 90 Hz.\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section.\n\n\n\n\n\nNewly written modules (enabled FF and top level) were tested using automated verilog testbenches to ensure that all sums were correct in the outputs, that the power pins swapped at the correct frequency, and that the enabled FF worked as intended. See all testbench results below.\n Figure 3: Testbench waveforms showing the oscillating power states on the top module as well as functioning combinational LED logic\n Figure 4: Testbench results showing no errors when testing the counter\n\n\n\nTesting verification was done to confirm that the seven segment and LEDs displayed appropriate outputs based on switched inputs. All segments were equally bright, and there was no blending between the two displays due to coupling between the two inputs.\n\n\n\n\nIn this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 5 LEDs using a full adder, and used an oscillating FSM to control two separate seven segment LED displays using one decoder. Overall, I spent 5 hours on this lab.\n\n\n\nFollowing the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, a state-based solution was created to independently take the inputs of two 4-segment switches (to represent hex numbers) and display them on a two-diget seven segment display using only one seven segment decoder, necessitating an FSM. A switching frequency was generated, and addtionally, the sum of the two switches at any given time was displayed using a string of LEDs in binary representation."
  },
  {
    "objectID": "labs/lab2/lab2.html#block-diagram",
    "href": "labs/lab2/lab2.html#block-diagram",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The block diagram in the below image shows the hierarchical structure of the Verilog modules written for this lab. The top module (lab2_ly) contains all other modules, and the HSOSC module from the UP5K board is used. A counter module was reused from lab 1 to modulate the clock down to ~90 Hz on the 17st bit of the counter, allowing it to oscillate the power between our two sides of the seven segment display, also representing our two states. A single decoder determined the multiplexed selection between the two switch outputs, and a full adder determined the LED binary output.\n Figure 1: Block diagram of hierarchical SystemVerilog"
  },
  {
    "objectID": "labs/lab2/lab2.html#schematic",
    "href": "labs/lab2/lab2.html#schematic",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The two schematics below show how the LEDs in the given system are powered. The 7-segment display common power pins are given a ~3.3V input through a PNP transistor with 1 \\(\\mu A\\) at the base (necessitating an ~330 \\(\\Omega\\) resistor), and pins at the end of them are pulled high to turn off a given segment. Only one set of pins was powered and pulled appropriately at any given time, and the 90 Hz oscillating frequency ensured stable powering without blending of the two signals. As per the last lab, a 200 \\(\\Omega\\) resistor was selected as a current limiting resistor. The pins connected to the breakout switch were connected to ground with pullup resistors set on the FPGA pins.\n Figure 2: Schematic for the breakout board"
  },
  {
    "objectID": "labs/lab2/lab2.html#design-testing-and-methodology",
    "href": "labs/lab2/lab2.html#design-testing-and-methodology",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The onboard oscillator was used from the iCE40 UltraPlus FPGA to generate a clock pulse, which was used with a SystemVerilog counter/clock divider module to control the oscillating LED. The switch banks on the development board and breakout board were used to represent the four binary bits of two hexadecimal numbers, and these switches fed into a full adder to determine when onboard LEDs should be enabled. A state machine toggled between the two switch inputs into the decoder, powering the relevant side of the seven segment display in the process All current-limiting resistors for the 7-segment display were determined with a target current of 7 \\(\\mu A\\) and a voltage drop across the LEDs of 1.95 V, leading to a resistance value of ~ 200 \\(\\Omega\\). A 330 \\(\\Omega\\) resistor was used from the enable pins to power into the base of a PNP transistor with a target current of 1 \\(\\mu A\\). This then fed into the seven segment display from a 3V3 feed on the collector, and the transistors with oscillating base inputs swapped power at about 90 Hz.\nAll modules were tested using automatic Verilog testbenches as shown in the Results and Discussion section."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Newly written modules (enabled FF and top level) were tested using automated verilog testbenches to ensure that all sums were correct in the outputs, that the power pins swapped at the correct frequency, and that the enabled FF worked as intended. See all testbench results below.\n Figure 3: Testbench waveforms showing the oscillating power states on the top module as well as functioning combinational LED logic\n Figure 4: Testbench results showing no errors when testing the counter\n\n\n\nTesting verification was done to confirm that the seven segment and LEDs displayed appropriate outputs based on switched inputs. All segments were equally bright, and there was no blending between the two displays due to coupling between the two inputs."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I created a SystemVerilog hierarchy and accompanying breakout board that controlled 5 LEDs using a full adder, and used an oscillating FSM to control two separate seven segment LED displays using one decoder. Overall, I spent 5 hours on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype",
    "href": "labs/lab2/lab2.html#ai-prototype",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 1, the following prompt was passed into ChatGPT:\nWrite SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\nThe model handled this shockingly well, and no major errors were found in the code itself. It used a slightly lazy way to create a counter, resetting the counter value every time the correct number of cycles had passed rather than creating a counter that uses a P value and the final bit of an N bit counter (as taught in E85). However, this compiled and worked in the Radiant simulation. However, a minor issue that I did notice was that ChatGPT thought the onboard high speed oscillator operated at 12 MHz, not 48 MHz as it actually operates. When this was pointed out to GPT, it quickly corrected that line.\n Figure 8: Code for the oscillator written by ChatGPT, which has many strange ways to specify bit length but otherwise seems very feasible\nAnother issue that I noticed is that the bit lengths of many constants were not specified. Knowing how many different examples of counters must be in the model, it makes sense that these things would be issues, but it still is slightly surprising that it was so much of an issue. A lot of them only generated warnings in Radiant, but if the code were to be passed through something like Verilator or another SystemVerilog linting program, it would likely point out a lot of other isues as well."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, interrupts and GPIO pins were configured with a counter on the STM32L432KC to read a quadrature encoder on a TS-25GA370H-34 motor. This quadrature encoder reading was used to determine angular velocity of the motor.\n\n\n\nFor the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s. This enabled us to create a simple 1 Hz telemetry loop that reports velocity and direction of rotation for this lab.\n\n\n\nThe below schematic shows how this circuit was constructed. An external 20V variable power supply was connected to the power and ground pins for our motor we used for testing our system. The 5V, GND, quadrature A, and quadrature B pins were connected to their corresponding MCU pins directly. All pins were enabled with pull-up resistors.\n Figure 1: Electrical schematic for system\n\n\n\nThe below diagram shows the control loop present in this system. A main loop ran a 1 Hz cycle that printed velocity and reset counter values before repeating, giving us a telemetry status. The two interrupts both incremented a counter that tracked the number of quadrature encoder edges seen in the past second, and they also tracked which interrupt was last checked. If the same interrupt triggered 2x in a row, it meant that the motor had changed direction, which we could track globally.\n Figure 2: Interrupt diagram for system\n\n\n\n\n\nWhen initializing the program, the code appropriately output a 0 for velocity. Upon activating, it correctly determined our control velocity for the motor (2.4 rev/sec at 10 V), and was also able to detect changes in direction when reversing the current path through the motor.\n\n\n\nWe were able to test the speed of entering an interrupt v.s. reading a toggled pin with polling by writing code to simulate both situations. First set the start of our interrupt function to toggle a pin on, then read the time between an interrupt being raised and the pin being toggled. As seen below, the time from the onset of an interrupt signal to the first line of the function that toggled the pin took 26.4 \\(\\mu s\\). By comparison, having a polling loop that toggled a pin then read an input took 63.6 \\(\\mu s\\). This indicates that interrupts will be more efficient when polling at the rate that we will be at.\n Figure 3: Oscilloscope trace showing interrupt response time\n Figure 4: Oscilloscope trace showing polling response time\n\n\n\n\nIn this lab, I created an interrupt based velocity measurement system using the quadrature encoders present on a 25GA-370 motor. The motor correctly determined direction changes and velocity magnitude. Overall, this lab took me 9 hours.\n\n\n\nFollowing the directions for the AI Prototype for lab 5, the following prompt was passed into ChatGPT:\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\nThe AI model did not do very well on this task. The first thing it did was enable interrupts for every edge of the program. However, it missed setting some of the signal select muxes that tell the interrupt handlers where to look for interrupt signals. As a result, this code did not successfully run because it couldn’t recognize interrupts. See the below code from GPT.\n Figure 5: Code for the interrupt enables written by ChatGPT, which is missing key register writes\nThe interrupt handler itself also has a critical bug, which will incorrectly decrement the counter when \\(A == B\\). As a result, I do not believe this code would have correctly incremented and tracked speed, outputting something very close to 0 every telemetry frame.\n Figure 6: Code for interrupt handlers written by ChatGPT, which does not correctly increment counter"
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, interrupts and GPIO pins were configured with a counter on the STM32L432KC to read a quadrature encoder on a TS-25GA370H-34 motor. This quadrature encoder reading was used to determine angular velocity of the motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#timer-calculations",
    "href": "labs/lab5/lab5.html#timer-calculations",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "For the timer, we used a prescaler (clock divider) value of \\(clk_{system} / 1000\\), meaning each clk on the timer was 1 ms. This means that the range of values for our duration timer is anywhere from 1 to 65535 ms, or .001 to 65.535 s. This enabled us to create a simple 1 Hz telemetry loop that reports velocity and direction of rotation for this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#schematic",
    "href": "labs/lab5/lab5.html#schematic",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The below schematic shows how this circuit was constructed. An external 20V variable power supply was connected to the power and ground pins for our motor we used for testing our system. The 5V, GND, quadrature A, and quadrature B pins were connected to their corresponding MCU pins directly. All pins were enabled with pull-up resistors.\n Figure 1: Electrical schematic for system"
  },
  {
    "objectID": "labs/lab5/lab5.html#interrupt-diagram",
    "href": "labs/lab5/lab5.html#interrupt-diagram",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "The below diagram shows the control loop present in this system. A main loop ran a 1 Hz cycle that printed velocity and reset counter values before repeating, giving us a telemetry status. The two interrupts both incremented a counter that tracked the number of quadrature encoder edges seen in the past second, and they also tracked which interrupt was last checked. If the same interrupt triggered 2x in a row, it meant that the motor had changed direction, which we could track globally.\n Figure 2: Interrupt diagram for system"
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "When initializing the program, the code appropriately output a 0 for velocity. Upon activating, it correctly determined our control velocity for the motor (2.4 rev/sec at 10 V), and was also able to detect changes in direction when reversing the current path through the motor.\n\n\n\nWe were able to test the speed of entering an interrupt v.s. reading a toggled pin with polling by writing code to simulate both situations. First set the start of our interrupt function to toggle a pin on, then read the time between an interrupt being raised and the pin being toggled. As seen below, the time from the onset of an interrupt signal to the first line of the function that toggled the pin took 26.4 \\(\\mu s\\). By comparison, having a polling loop that toggled a pin then read an input took 63.6 \\(\\mu s\\). This indicates that interrupts will be more efficient when polling at the rate that we will be at.\n Figure 3: Oscilloscope trace showing interrupt response time\n Figure 4: Oscilloscope trace showing polling response time"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "In this lab, I created an interrupt based velocity measurement system using the quadrature encoders present on a 25GA-370 motor. The motor correctly determined direction changes and velocity magnitude. Overall, this lab took me 9 hours."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype",
    "href": "labs/lab5/lab5.html#ai-prototype",
    "title": "HMC E155 Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Following the directions for the AI Prototype for lab 5, the following prompt was passed into ChatGPT:\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\nThe AI model did not do very well on this task. The first thing it did was enable interrupts for every edge of the program. However, it missed setting some of the signal select muxes that tell the interrupt handlers where to look for interrupt signals. As a result, this code did not successfully run because it couldn’t recognize interrupts. See the below code from GPT.\n Figure 5: Code for the interrupt enables written by ChatGPT, which is missing key register writes\nThe interrupt handler itself also has a critical bug, which will incorrectly decrement the counter when \\(A == B\\). As a result, I do not believe this code would have correctly incremented and tracked speed, outputting something very close to 0 every telemetry frame.\n Figure 6: Code for interrupt handlers written by ChatGPT, which does not correctly increment counter"
  }
]